

inla.mesh2sp <- function(mesh) {
  
  # Taken from google groups https://groups.google.com/g/r-inla-discussion-group/c/z1n1exlZrKM/m/8vYNr2D8BwAJ
  # Convert inla.mesh to sp objects
  #
  # @param mesh An \code{\link{inla.mesh}} object
  # @return A list with \code{sp} objects for triangles and vertices:
  # \describe{
  # \item{triangles}{\code{SpatialPolygonsDataFrame} object with the triangles in
  # the same order as in the original mesh, but each triangle looping through
  # the vertices in clockwise order (\code{sp} standard) instead of
  # counterclockwise order (\code{inla.mesh} standard). The \code{data.frame}
  # contains the vertex indices for each triangle, which is needed to link to
  # functions defined on the vertices of the triangulation.
  # \item{vertices}{\code{SpatialPoints} object with the vertex coordinates,
  # in the same order as in the original mesh.}


  crs <- inla.CRS(inla.CRSargs(mesh$crs))
  isgeocentric <- identical(inla.as.list.CRS(crs)[["proj"]], "geocent")
  if (isgeocentric || (mesh$manifold == "S2")) {
    stop(paste0(
      "'sp' doesn't support storing polygons in geocentric coordinates.\n",
      "Convert to a map projection with inla.spTransform() before
calling inla.mesh2sp()."))
  }
  
  triangles <- SpatialPolygonsDataFrame(
    Sr = SpatialPolygons(lapply(
      1:nrow(mesh$graph$tv),
      function(x) {
        tv <- mesh$graph$tv[x, , drop = TRUE]
        Polygons(list(Polygon(mesh$loc[tv[c(1, 3, 2, 1)],
                                       1:2,
                                       drop = FALSE])),
                 ID = x)
      }
    ),
    proj4string = crs
    ),
    data = as.data.frame(mesh$graph$tv[, c(1, 3, 2), drop = FALSE]),
    match.ID = FALSE
  )
  vertices <- SpatialPoints(mesh$loc[, 1:2, drop = FALSE], proj4string = crs)
  
  list(triangles = triangles, vertices = vertices)
}



#_______________________________________________________________________________


make_prediction_map <- function(A_matrix, P_vector,remove_obs=F){
  
  # Use this function to create a dataframe containing INLA predictions with their locations.
  
  # A_matrix = Locp, a matrix of locations (x and y) specified in the INLA model
  # P_vector = p.pred, a vector containing the predictions generated by INLA
  # if remove_obs=T, the 'observation' column will be removed from the final df (useful for merging)
  
  library(dplyr)
  
  A_df <- as.data.frame(A_matrix*1000)
  A_df$observation <- 1:nrow(A_df) 
  colnames(A_df)[1:2]<-c("xm","ym")
  
  P_df <- as.data.frame(P_vector)
  colnames(P_df)<-c(substitute(P_vector))
  P_df$observation <- 1:nrow(P_df) 
  
  
  df_full <- merge(A_df,P_df,by="observation")
  
  if(remove_obs == T){
    df_full <- df_full[,2:4]}
  
  return(df_full)
  
}

#_______________________________________________________________________________

append_prediction_map <- function(Existing_df, P_vector,remove_obs=F){
  

  # Use this function to append a vector onto an existing df with the same number of rows.
  # Ideally used to append additional INLA predictions to existing prediction df 
  # for example, to add in predictions based on different climactic scenarios OR
  # to combine the predictive outputs of different model formulations 
  # The x and y matrix must be the same
  
  # A_matrix = Locp, a matrix of locations (x and y)
  # P_vector = p.pred, a vector containing the predictions generated by INLA
  # if remove_obs=T, the 'observation' column will be removed from the final df (useful for merging)
  
   library(dplyr) 
  P_df <- as.data.frame(P_vector)
  colnames(P_df)<-c(substitute(P_vector))
  P_df$observation <- 1:nrow(P_df) 
  
  if(!"observation" %in% colnames(Existing_df))
  {
    Existing_df$observation <- 1:nrow(Existing_df) 
  }
  
  df_full <- merge(Existing_df,P_df,by="observation")
  
  if(remove_obs == T){
    df_full <- df_full[,-1]}
  
  return(df_full) 
}

#_______________________________________________________________________________

# Shoot hole in polygon (spdf) using another polygon (spdf)
# https://stackoverflow.com/questions/29624895/how-to-add-a-hole-to-a-polygon-within-a-spatialpolygonsdataframe

library("sp")
AddHoleToPolygon <-function(poly,hole){
  # invert the coordinates for Polygons to flag it as a hole
  coordsHole <-  hole@polygons[[1]]@Polygons[[1]]@coords
  newHole <- Polygon(coordsHole,hole=TRUE)
  
  # punch the hole in the main poly
  listPol <- poly@polygons[[1]]@Polygons
  listPol[[length(listPol)+1]] <- newHole
  punch <- Polygons(listPol,poly@polygons[[1]]@ID)
  
  # make the polygon a SpatialPolygonsDataFrame as the entry
  new <- SpatialPolygons(list(punch),proj4string=poly@proj4string)
  new <- SpatialPolygonsDataFrame(new,data=as(poly,"data.frame"))
  
  return(new)
}

